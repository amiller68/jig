# Git Hooks Management

**Status:** Planned  
**Priority:** High  
**Category:** Features

## Objective

Implement robust git hooks installation, management, and idempotent `jig init` that safely installs/updates hooks without breaking existing user hooks.

## Background

Git hooks are critical for:
- Updating worker metrics on commit/merge
- Triggering health checks after operations
- Enforcing conventional commits (optional)
- Auto-updating issue status

But hooks are tricky:
- Users might have existing hooks
- Need to be idempotent (safe to run multiple times)
- Need to support hook chaining
- Need to be uninstallable

## Architecture

### Hook Wrapper Pattern

**Instead of replacing hooks, wrap them:**

`.git/hooks/post-commit` (generated by jig):
```bash
#!/bin/bash
# jig-managed: v1
# This hook was installed by jig. To uninstall: jig hooks uninstall

# Run jig handler
~/.cargo/bin/jig hooks post-commit "$@" || true

# Run user hook if it exists
if [ -f .git/hooks/post-commit.user ]; then
    .git/hooks/post-commit.user "$@"
fi
```

**User hooks go in `.user` suffix:**
- `.git/hooks/post-commit.user` - user's custom hook
- `.git/hooks/pre-commit.user` - user's custom hook

### Hook Registry

**Track installed hooks in `.git/jig-hooks.json`:**

```json
{
  "version": "1",
  "installed": {
    "post-commit": {
      "installed_at": "2026-02-19T10:00:00Z",
      "jig_version": "0.6.0",
      "had_existing": true,
      "backed_up_to": ".git/hooks/post-commit.backup-2026-02-19"
    },
    "post-merge": {
      "installed_at": "2026-02-19T10:00:00Z",
      "jig_version": "0.6.0",
      "had_existing": false
    }
  }
}
```

### Hook Handlers

**In jig-core:**

```rust
pub mod hooks {
    pub fn handle_post_commit(repo_path: &Path) -> Result<()> {
        // Update metrics
        let metrics = collect_git_metrics(repo_path)?;
        update_health_state(repo_path, |state| {
            state.last_commit_at = metrics.last_commit_at;
            state.commit_count = metrics.commit_count;
            state.reset_nudge_count("idle");
        })?;
        
        // Optionally trigger health check
        if config.health.check_on_commit {
            run_health_check(repo_path)?;
        }
        
        Ok(())
    }
    
    pub fn handle_post_merge(repo_path: &Path) -> Result<()> {
        // Reset conflict nudge count
        update_health_state(repo_path, |state| {
            state.reset_nudge_count("conflict");
        })?;
        
        // Trigger health check
        if config.health.check_on_merge {
            run_health_check(repo_path)?;
        }
        
        Ok(())
    }
    
    pub fn handle_pre_commit(repo_path: &Path, msg_file: &Path) -> Result<()> {
        // Validate conventional commits if enabled
        if config.github.require_conventional_commits {
            let msg = fs::read_to_string(msg_file)?;
            validate_commit_message(&msg, &config.conventional_commits)?;
        }
        
        Ok(())
    }
}
```

## Commands

```bash
# Install hooks (safe, idempotent)
jig init
jig init  # Run again, no errors

# Install specific hooks
jig hooks install post-commit post-merge

# Reinstall/update hooks
jig hooks reinstall

# List installed hooks
jig hooks list

# Show hook status
jig hooks status

# Uninstall hooks (restore backups if exist)
jig hooks uninstall

# Test hook execution
jig hooks test post-commit
```

## Idempotent Init

**`jig init` safety guarantees:**

1. Check if hooks already installed (marker in hook file)
2. If user hook exists, back it up and move to `.user` suffix
3. Install jig wrapper hook
4. Track installation in `.git/jig-hooks.json`
5. Running again: verify hooks are up-to-date, no changes needed

**Implementation:**
```rust
pub fn init_hooks(repo_path: &Path, force: bool) -> Result<InitResult> {
    let hooks_dir = repo_path.join(".git/hooks");
    let registry_path = repo_path.join(".git/jig-hooks.json");
    
    // Load or create registry
    let mut registry = if registry_path.exists() {
        serde_json::from_str(&fs::read_to_string(&registry_path)?)?
    } else {
        HookRegistry::new()
    };
    
    let hooks_to_install = vec!["post-commit", "post-merge", "pre-commit"];
    let mut results = Vec::new();
    
    for hook_name in hooks_to_install {
        let hook_path = hooks_dir.join(hook_name);
        
        // Check if already installed
        if hook_path.exists() {
            let content = fs::read_to_string(&hook_path)?;
            
            if content.contains("# jig-managed: v1") {
                // Already installed
                if !force {
                    results.push(HookResult::AlreadyInstalled(hook_name.to_string()));
                    continue;
                }
                // Force reinstall
            } else {
                // User hook exists, back it up
                let backup_name = format!("{}.backup-{}", hook_name, now_iso());
                let backup_path = hooks_dir.join(&backup_name);
                fs::rename(&hook_path, &backup_path)?;
                
                // Move to .user suffix
                let user_path = hooks_dir.join(format!("{}.user", hook_name));
                fs::copy(&backup_path, &user_path)?;
                
                registry.mark_existing_backed_up(hook_name, &backup_name);
            }
        }
        
        // Install jig hook
        let hook_content = generate_hook_wrapper(hook_name);
        fs::write(&hook_path, hook_content)?;
        make_executable(&hook_path)?;
        
        registry.mark_installed(hook_name);
        results.push(HookResult::Installed(hook_name.to_string()));
    }
    
    // Save registry
    fs::write(&registry_path, serde_json::to_string_pretty(&registry)?)?;
    
    Ok(InitResult { results })
}
```

## Hook Templates

**Embedded in jig binary:**

```rust
const POST_COMMIT_HOOK: &str = r#"#!/bin/bash
# jig-managed: v1
# This hook was installed by jig. To uninstall: jig hooks uninstall
# User hooks: place in .git/hooks/post-commit.user

set -e

# Run jig handler
if command -v jig &> /dev/null; then
    jig hooks post-commit "$@" || true
fi

# Run user hook if it exists
if [ -f .git/hooks/post-commit.user ]; then
    .git/hooks/post-commit.user "$@"
fi
"#;

const POST_MERGE_HOOK: &str = r#"#!/bin/bash
# jig-managed: v1
# This hook was installed by jig. To uninstall: jig hooks uninstall

set -e

if command -v jig &> /dev/null; then
    jig hooks post-merge "$@" || true
fi

if [ -f .git/hooks/post-merge.user ]; then
    .git/hooks/post-merge.user "$@"
fi
"#;

const PRE_COMMIT_HOOK: &str = r#"#!/bin/bash
# jig-managed: v1
# This hook was installed by jig. To uninstall: jig hooks uninstall

set -e

# Run jig validation (can fail commit)
if command -v jig &> /dev/null; then
    jig hooks pre-commit "$@"
fi

# Run user hook if it exists
if [ -f .git/hooks/pre-commit.user ]; then
    .git/hooks/pre-commit.user "$@"
fi
"#;
```

## Hook Chain Execution

**Sequence for post-commit:**
1. User commits
2. Git calls `.git/hooks/post-commit`
3. jig wrapper runs `jig hooks post-commit`
4. jig updates metrics, resets nudges
5. jig optionally triggers health check
6. jig wrapper runs `.git/hooks/post-commit.user` (if exists)
7. User's custom hook executes

**Error handling:**
- jig handlers always exit 0 (never block commits)
- User hooks can fail and block (their choice)
- All output captured and logged

## Configuration

**Per-repo in `jig.toml`:**

```toml
[hooks]
# Enable/disable specific hooks
enabled = ["post-commit", "post-merge", "pre-commit"]

# Run health check after commit
checkOnCommit = false

# Run health check after merge
checkOnMerge = true

# Validate conventional commits (blocks commit if invalid)
validateCommits = false

# Log hook execution (for debugging)
logExecution = false
logPath = ".git/jig-hooks.log"
```

## Uninstallation

**`jig hooks uninstall` steps:**
1. Check `.git/jig-hooks.json` for installed hooks
2. For each hook:
   - Remove jig wrapper hook
   - If backup exists, restore it
   - If `.user` suffix exists, move to main hook path
3. Delete `.git/jig-hooks.json`
4. Report what was restored

**Safe rollback:**
```bash
$ jig hooks uninstall

Uninstalling jig hooks...

✓ post-commit: removed wrapper, restored backup from 2026-02-19
✓ post-merge: removed wrapper (no previous hook)
✓ pre-commit: removed wrapper, restored .user hook

All jig hooks uninstalled.
Your original hooks have been restored.
```

## Implementation Phases

### Phase 1: Core Infrastructure
1. Hook registry data structures
2. Hook wrapper templates
3. `jig hooks` subcommand scaffolding

### Phase 2: Installation
1. Idempotent init logic
2. Backup and `.user` suffix handling
3. Hook template rendering
4. Make hooks executable

### Phase 3: Handlers
1. `jig hooks post-commit` handler
2. `jig hooks post-merge` handler
3. `jig hooks pre-commit` handler (validation)
4. Integration with health system

### Phase 4: Management
1. `jig hooks list/status`
2. `jig hooks reinstall`
3. `jig hooks uninstall` with safe rollback
4. Hook execution logging

## Acceptance Criteria

### Installation
- [ ] `jig init` installs hooks safely
- [ ] Idempotent: running `jig init` twice is safe
- [ ] Backs up existing user hooks to `.backup-*`
- [ ] Moves existing hooks to `.user` suffix
- [ ] Creates `.git/jig-hooks.json` registry
- [ ] Hooks are executable (chmod +x)

### Hook Wrappers
- [ ] Generated hooks contain `# jig-managed: v1` marker
- [ ] Hooks call `jig hooks <name>` handler
- [ ] Hooks chain to `.user` suffix if exists
- [ ] Hooks never block (exit 0 from jig handlers)

### Handlers
- [ ] `post-commit`: update metrics, reset idle nudges
- [ ] `post-merge`: reset conflict nudges
- [ ] `pre-commit`: validate commits if enabled (can block)
- [ ] Handlers are fast (<100ms)

### Uninstallation
- [ ] `jig hooks uninstall` removes all jig hooks
- [ ] Restores backups if they exist
- [ ] Restores `.user` hooks to main path
- [ ] Deletes `.git/jig-hooks.json`
- [ ] Reports what was restored

### Configuration
- [ ] Per-repo hook enablement in `jig.toml`
- [ ] Configurable health check triggers
- [ ] Configurable commit validation
- [ ] Hook execution logging

## Testing

```bash
# Fresh repo, no existing hooks
cd test-repo
jig init
ls -la .git/hooks/
# Should see: post-commit, post-merge, pre-commit (all executable)

# Verify marker
cat .git/hooks/post-commit | grep "jig-managed: v1"

# Create user hook
cat > .git/hooks/post-commit.user << 'EOF'
#!/bin/bash
echo "User hook executed"
EOF
chmod +x .git/hooks/post-commit.user

# Make a commit, verify both hooks run
git commit --allow-empty -m "test"
# Should see: metrics updated + "User hook executed"

# Run init again (idempotent test)
jig init
# Should report: hooks already installed, no changes

# Uninstall
jig hooks uninstall
ls -la .git/hooks/
# Should see: post-commit (from .user), no post-merge/pre-commit

# Verify user hook still works
git commit --allow-empty -m "test2"
# Should see: "User hook executed" (no jig metrics update)
```

## Open Questions

1. Should hooks be optional? (Yes, configurable in `jig.toml`)
2. Should we support husky-style hooks? (No, native git hooks only)
3. Should pre-commit validation be strict by default? (No, opt-in)
4. Should we support Windows? (Yes, use `#!/bin/sh` shebang + cross-platform paths)

## Related Issues

- issues/features/worker-heartbeat-system.md (uses hook metrics)
- issues/features/github-integration.md (commit validation)
- issues/improvements/worker-activity-metrics.md (updated by hooks)
